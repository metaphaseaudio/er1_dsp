#pragma once
//
// Created by Matt Zapp on 4/3/2018.
//


#include <array>
#include <cstdint>
#include <meta/audio/Asymp.h>
#include <meta/dsp/OnePoleLowPassFilter.h>
#include <meta/dsp/BandlimitedWavetable.h>
#include <meta/util/fixed_point/Value.h>
#include "Types.h"

namespace meta
{
    namespace ER1
    {
        /**
         * This class defines a bandlimited wavetable oscillator that is used for
         * many of basic virtual analog synthesis functions in the ER-1.
         *
         * It offers the 2 audio-rate and 2 of the modulation-rate waveforms
         * originally supported by the ER-1: Sine, Triangle, Saw, and Square.
         * Analysis of the audio-rate waveforms indicates that the Triangle and
         * Sine functions are actually generated by integrating a bandlimited Square
         * signal, and thus the Triangle is not a clean shape, and the Sine includes
         * some additional odd harmonics in keeping with the original.
         */
        class Oscillator
        {
            // Compile-time constants
            static constexpr int HARMONIC_COUNT { 50 };
            static constexpr const bool csm_LimitFreq = true;
        public:
            enum WaveType
            {
				PURE_SINE = 0
                , SINE
                , TRIANGLE
                , SQUARE
                , SAW
            };

            WaveType waveType = WaveType::SINE;

            /// Makes an ER-1 Oscillator
            Oscillator();

            /// Produce the next sample of the waveform
            inline float tick()
			{
				const auto pureSine = m_WaveTable[m_TablePhases[0].integral()];
				const auto square = sumPartials(odds);
				const auto saw = (sumPartials(evens) + square) * 0.5f;
				const auto tri = m_Integrate.processSample(square) * 1.41254f;
				const auto sine = m_SineFilter.processSample(tri);

				advanceAllPartials();

				switch (waveType)
				{
				default:
				case WaveType::PURE_SINE: return pureSine;
				case WaveType::SINE:     return sine;
				case WaveType::TRIANGLE: return tri;
				case WaveType::SQUARE:   return square;
				case WaveType::SAW:      return float(saw);
				}
			}

            /**
             * Reset the Oscillator to pi (not 0!)
             * When Integrating a Square wave from its 0 value, a Triangle wave
             * will start at 0 and rise, but the ER-1 decays from 1, thus the
             * underlying function needs to either start at pi or be generated
             * from cosine instead of sine.
             */
            void sync();

            void setFrequency(float freq);

        private:
            enum Partials { odds, evens };

            void advanceAllPartials();

            float sumPartials(Partials p);

            meta::OnePoleLowPassFilter m_Integrate;
            meta::OnePoleLowPassFilter m_SineFilter;

            fixed_t m_TablePhases[HARMONIC_COUNT];
            fixed_t m_TableDeltas[HARMONIC_COUNT];
			fixed_t m_MaxDelta;
			
			float m_CoeffsLin[HARMONIC_COUNT];
            float m_CoeffsTri[HARMONIC_COUNT];

            static std::array<float, 256> m_WaveTable;
        };
    }
}

