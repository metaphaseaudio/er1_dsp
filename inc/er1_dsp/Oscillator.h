#pragma once
//
// Created by Matt Zapp on 4/3/2018.
//


#include <array>
#include <cstdint>
#include <meta/audio/Asymp.h>
#include <meta/dsp/OnePoleLowPassFilter.h>
#include <meta/dsp/BandlimitedWavetable.h>
#include <meta/util/fixed_point/Value.h>
#include "Types.h"

namespace meta
{
    namespace ER1
    {
        /**
         * This class defines a bandlimited wavetable oscillator that is used for
         * many of basic virtual analog synthesis functions in the ER-1.
         *
         * It offers the 2 audio-rate and 2 of the modulation-rate waveforms
         * originally supported by the ER-1: Sine, Triangle, Saw, and Square.
         * Analysis of the audio-rate waveforms indicates that the Triangle and
         * Sine functions are actually generated by integrating a bandlimited Square
         * signal, and thus the Triangle is not a clean shape, and the Sine includes
         * some additional odd harmonics in keeping with the original.
         */
        class Oscillator
        {
            // Compile-time constants
            static constexpr int HARMONIC_COUNT { 50 };
            static constexpr int TABLE_SIZE { 256 };
            static constexpr const bool csm_LimitFreq = true;
        public:
            enum WaveType
            {
				PURE_SINE = 0
                , SINE
                , TRIANGLE
                , SQUARE
                , SAW
            };

            WaveType waveType = WaveType::SINE;

            /// Makes an ER-1 Oscillator
            Oscillator(float init_freq=250.0f);

            /// Produce the next sample of the waveform
            inline float tick()
			{
				advanceAllPartials();

				switch (waveType)
				{
				default:
				case WaveType::PURE_SINE: return m_WaveTable[static_cast<int>(m_TablePhases[0])];
				case WaveType::SINE:      return m_SineFilter.processSample(sumPartials(odds, m_CoeffsTri));
				case WaveType::TRIANGLE:  return sumPartials(odds, m_CoeffsTri);
				case WaveType::SQUARE:    return sumPartials(odds, m_CoeffsLin);
				case WaveType::SAW:       return (sumPartials(evens, m_CoeffsLin) + sumPartials(odds, m_CoeffsLin)) * 0.5f;
				}
			}

            /**
             * Reset the Oscillator to pi (not 0!)
             * When Integrating a Square wave from its 0 value, a Triangle wave
             * will start at 0 and rise, but the ER-1 decays from 1, thus the
             * underlying function needs to either start at pi or be generated
             * from cosine instead of sine.
             */
            void sync();

            void setFrequency(float freq);

        private:
            float m_Frequency;
            enum Partials { odds, evens };

            void advanceAllPartials();

            float sumPartials(Partials p, const float* gainCoeffs);

            meta::OnePoleLowPassFilter m_Integrate;
            meta::OnePoleLowPassFilter m_SineFilter;

            float m_TablePhases[HARMONIC_COUNT];
            float m_TableDeltas[HARMONIC_COUNT];
			float m_MaxDelta;

			float m_CoeffsLin[HARMONIC_COUNT];
            float m_CoeffsTri[HARMONIC_COUNT];

            static std::array<float, TABLE_SIZE> m_WaveTable;
        };
    }
}

