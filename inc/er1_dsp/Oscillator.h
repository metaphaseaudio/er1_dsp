#pragma once
//
// Created by Matt Zapp on 4/3/2018.
//


#include <array>
#include <cstdint>
#include <meta/audio/Asymp.h>
#include <meta/dsp/OnePoleLowPassFilter.h>
#include <meta/dsp/BandlimitedWavetable.h>
#include <meta/dsp/WavetableReader.h>
#include <meta/util/fixed_point/Value.h>
#include "Types.h"


namespace meta
{
    namespace ER1
    {
        /**
         * This class defines a band-limited wavetable oscillator that is used for
         * many of basic virtual analog synthesis functions in the ER-1.
         *
         * It offers the 2 audio-rate and 2 of the modulation-rate waveforms
         * originally supported by the ER-1: Sine, Triangle, Saw, and Square.
         * Analysis of the audio-rate waveforms indicates that the Triangle and
         * Sine functions are actually generated by integrating a band-limited Square
         * signal, and thus the Triangle is not a clean shape, and the Sine includes
         * some additional odd harmonics in keeping with the original.
         */
        class Oscillator
        {
            // Compile-time constants
            static constexpr int HARMONIC_COUNT { 50 };
            static constexpr int TABLE_SIZE { 256 };
            static constexpr const bool csm_LimitFreq = true;

        public:
            enum WaveType
            {
                SINE = 0
                , TRIANGLE
                , SQUARE
                , SAW
            };

            /// Makes an ER-1 Oscillator
            Oscillator(float sample_rate, float init_freq=250.0f, WaveType wt=WaveType::SINE);

            /// Produce the next sample of the waveform
            inline float tick()
			{
                float rv = 0;
                for (auto harm : m_Harmonics) { rv += harm.reader.tick() * harm.gain; }
                return (m_WaveType == SINE) ? m_SineFilter.processSample(rv) : rv;
			}

            /**
             * Reset the Oscillator to pi (not 0!)
             * When Integrating a Square wave from its 0 value, a Triangle wave
             * will start at 0 and rise, but the ER-1 decays from 1, thus the
             * underlying function needs to either start at pi or be generated
             * from cosine instead of sine.
             */
            void sync();
            void setFrequency(float sampleRate, float freq);
            void setWaveType(WaveType t);

        private:
            struct Harmonic
            {
                Harmonic()
                    : reader(Oscillator::m_WaveTable, state)
                    , gain(0)
                {}

                meta::WavetableState<float> state;
                meta::WavetableReader<float, TABLE_SIZE> reader;
                float gain;
            };

            float m_Frequency;
            float m_SampleRate;
            WaveType m_WaveType;
            meta::OnePoleLowPassFilter m_Integrate;
            meta::OnePoleLowPassFilter m_SineFilter;

            float m_MaxDelta;
            std::array<Harmonic, HARMONIC_COUNT> m_Harmonics;
            static std::array<float, TABLE_SIZE> m_WaveTable;
        };
    }
}

